// @COPYRIGHT@
// Licensed under MIT license (LICENSE.txt)

// clxx/util/enum2hex.hpp

/** // doc: clxx/util/enum2hex.hpp {{{
 * \file clxx/util/enum2hex.hpp
 * \brief Provides #enum2hex() function
 */ // }}}
#ifndef CLXX_UTIL_ENUM2HEX_HPP_INCLUDED
#define CLXX_UTIL_ENUM2HEX_HPP_INCLUDED

#include <string>
#include <type_traits>

#include <yaul/tml/string.hpp>
#include <yaul/tml/num_to_string.hpp>
#include <yaul/tml/join.hpp>
#include <yaul/tml/c_str.hpp>
#include <yaul/tml/sequence.hpp>

namespace clxx { namespace detail {

/** // doc: enum_hex_fmt_prec {{{
 * \brief Generates the \em precision part of the formating string for integers
 *
 * Helper metafunction used by \ref clxx::detail::enum_hex_fmt "enum_hex_fmt".
 * It's responsible for generating the <tt>[.precision]</tt> part of the format
 * specifier that is generated by \ref clxx::detail::enum_hex_fmt "enum_hex_fmt".
 *
 * For a given integer type T, the function returns a compile-time string
 * starting with dot "." and followed by the minimum number of hexadecimal
 * digits to be written by \c printf (and cousins) when printing a value of
 * type \c T as a hexadecimal number.
 *
 * \tparam T must be an integral type
 */ // }}}
template<typename T>
  struct enum_hex_fmt_prec
    : yaul::tml::join<
        yaul::tml::string<'.'>
      , typename yaul::tml::num_to_string_c<std::size_t,sizeof(T)*2>::type
      >
  { };

/** // doc: enum_hex_fmt_prec {{{
 * \brief Generates the \em type part of the formating string for integers
 *
 * Helper meta-function used by \ref clxx::detail::enum_hex_fmt "enum_hex_fmt".
 * It's responsible for generating the type specifier part of the format
 * specifier that is generated by \ref clxx::detail::enum_hex_fmt
 * "enum_hex_fmt" (for example \c 'h' for <tt>signed char</tt> or <tt>signed
 * short</tt> and \c 'l' for <tt>signed long</tt>).
 *
 * \tparam T must be an integral type
 */ // }}}
template<typename T>
  struct enum_hex_fmt_argt
  {
    typedef typename yaul::tml::string<> type; ///< The resultant type
  };

/** \cond SHOW_TEMPLATE_SPECIALIZATIONS */
/// Specialization of the enum_hex_fmt_argt for <tt>signed char</tt>
template<>
  struct enum_hex_fmt_argt<signed char>
  { typedef typename yaul::tml::string<'h','h'> type; };
/// Specialization of the enum_hex_fmt_argt for <tt>signed short</tt>
template<>
  struct enum_hex_fmt_argt<signed short>
  { typedef typename yaul::tml::string<'h'> type; };
/// Specialization of the enum_hex_fmt_argt for <tt>signed long</tt>
template<>
  struct enum_hex_fmt_argt<signed long>
  { typedef typename yaul::tml::string<'l'> type; };
/// Specialization of the enum_hex_fmt_argt for <tt>signed long long</tt>
template<>
  struct enum_hex_fmt_argt<signed long long>
  { typedef typename yaul::tml::string<'l','l'> type; };
/// Specialization of the enum_hex_fmt_argt for <tt>size_t</tt>
template<>
  struct enum_hex_fmt_argt<size_t>
  { typedef typename yaul::tml::string<'z'> type; };
/** \endcond */

/** // doc: enum_hex_fmt {{{
 * \brief Generate formatting string for integers
 *
 * Helper meta-function used by #enum2hex().
 *
 * This meta-function generates at compile time a formating string for use
 * with \c printf and similar functions to represent integers of different
 * type in hexadecimal form. The string has form <tt>"0x%.PSx"</tt> or
 * <tt>"-0x%.PSx"</tt>, where \c P stands for precision specifier and
 * \c S is type specifier (\c x is a verbatim character in the formatting
 * string). The two specifiers \c P and \c S are determined automatically for
 * given integer type \em T.
 *
 * For example,
 * \code
 *    yaul::tml::c_str<detail::enum_hex_fmt<signed short,false>::type>::value
 * \endcode
 * would yield <tt>"0x%.4hx"</tt>, whereas
 * \code
 *    yaul::tml::c_str<detail::enum_hex_fmt<signed char,true>::type>::value
 * \endcode
 * would yield <tt>"-0x%.2hhx"</tt>, whereas
 *
 * The construction and interpretation of the formatting strings is explained
 * in the <a href="http://www.cplusplus.com/reference/cstdio/printf/">C++
 * reference page for printf</a>.
 *
 * \param T must be an integer type,
 * \param Negative whether the represented number is negative
 */ // }}}
template<typename T, bool Negative>
  struct enum_hex_fmt;

/** \cond SHOW_TEMPLATE_SPECIALIZATIONS */
template<typename T>
  struct enum_hex_fmt<T,false>
    : yaul::tml::join<
        typename yaul::tml::join<
          yaul::tml::string<'0','x','%'>
        , typename enum_hex_fmt_prec<T>::type
        >::type
      , typename yaul::tml::join<
          typename enum_hex_fmt_argt<T>::type
        , yaul::tml::string<'x'>
        >::type
      >
  { };
/// Specialization of the enum_hex_fmt for <tt>lt;T, true&gt;</tt>
template<typename T>
  struct enum_hex_fmt<T,true>
    : yaul::tml::join<
        typename yaul::tml::join<
          yaul::tml::string<'-','0','x','%'>
        , typename enum_hex_fmt_prec<T>::type
        >::type
      , typename yaul::tml::join<
          typename enum_hex_fmt_argt<T>::type
        , yaul::tml::string<'x'>
        >::type
      >
  { };
/** \endcond */

} } // end namespace clxx::detail

namespace clxx {

/** // doc: enum2hex(x) {{{
 * \brief Convert enum value to a string in hexadecimal representation
 *
 * Clxx defines a number of enum classes to represent certain features, error
 * codes and so on. Most of their values may be represented in human readable
 * form by functions such as #enum2cstr() of #enum2name(). It may happen,
 * however, that some of the values are not handled by these functions (for
 * example, they are not fully implemented due to some reasons). For such cases
 * the #enum2hex() function is used as a fallback.
 *
 * \param x the value to be converted, must be a value of enum type
 * \returns string which represents numerical value of \em e in a hexadecimal
 *          form
 */ // }}}
template<typename E>
std::string enum2hex(E x)
{
  typedef typename std::underlying_type<E>::type T;
  constexpr size_t size = 5 + 2 * sizeof(T);
  T t = static_cast<T>(x);
  char buf[size];
  char const *fmt;
  if (t < 0)
    {
      fmt = yaul::tml::c_str<typename detail::enum_hex_fmt<T,true>::type>::value;
      t = -t;
    }
  else
    {
      fmt = yaul::tml::c_str<typename detail::enum_hex_fmt<T,false>::type>::value;
    }
  std::snprintf(buf, size, fmt, t);
  return std::string(buf);
}

} // end namespace clxx
#endif /* CLXX_UTIL_ENUM2HEX_HPP_INCLUDED */
// vim: set expandtab tabstop=2 shiftwidth=2:
// vim: set foldmethod=marker foldcolumn=4:
