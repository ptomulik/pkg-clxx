// @COPYRIGHT@
// Licensed under MIT license (LICENSE.txt)

// clxx/util/to_string.hpp

/** // doc: clxx/util/to_string.hpp {{{
 * \file clxx/util/to_string.hpp
 * \brief Conversions of several types of data to string
 *
 * This header implements overloaded std::to_string for several types defined
 * in clxx.
 */ // }}}
#ifndef CLXX_UTIL_ENUM2HEX_HPP_INCLUDED
#define CLXX_UTIL_ENUM2HEX_HPP_INCLUDED

#include <string>
#include <type_traits>

#include <yaul/tml/string.hpp>
#include <yaul/tml/num_to_string.hpp>
#include <yaul/tml/join.hpp>
#include <yaul/tml/c_str.hpp>
#include <yaul/tml/sequence.hpp>

namespace clxx { namespace detail {

//
// The following metafunctions generate format string for sprinf() used when
// printing enums as hexadecimal numbers. The output from enum_hex_fmt is
// a string in form '0x%<prec><argt>x' where <prec> is a precision specifier
// generated by enum_hex_fmt_prec, and <argt> is an argument type specifier
// generated with enum_hex_fmt_argt.
//
// See also http://www.cplusplus.com/reference/cstdio/printf/.
//

/** // doc: enum_hex_fmt_prec {{{
 * \brief Precission
 * \todo Write documentation
 */ // }}}
template<typename T>
  struct enum_hex_fmt_prec
    : yaul::tml::join<
        yaul::tml::string<'.'>
      , typename yaul::tml::num_to_string_c<std::size_t,sizeof(T)*2>::type
      >
  { };

/** // doc: enum_hex_fmt_prec {{{
 * \brief Argument type
 * \todo Write documentation
 */ // }}}
template<typename T>
  struct enum_hex_fmt_argt
  {
    typedef typename yaul::tml::string<> type; ///< The resultant type
  };

/** \cond SHOW_TEMPLATE_SPECIALIZATIONS */
/// Specialization of the enum_hex_fmt_argt for <tt>signed char</tt>
template<>
  struct enum_hex_fmt_argt<signed char>
  { typedef typename yaul::tml::string<'h','h'> type; };
/// Specialization of the enum_hex_fmt_argt for <tt>signed short</tt>
template<>
  struct enum_hex_fmt_argt<signed short>
  { typedef typename yaul::tml::string<'h'> type; };
/// Specialization of the enum_hex_fmt_argt for <tt>signed long</tt>
template<>
  struct enum_hex_fmt_argt<signed long>
  { typedef typename yaul::tml::string<'l'> type; };
/// Specialization of the enum_hex_fmt_argt for <tt>signed long long</tt>
template<>
  struct enum_hex_fmt_argt<signed long long>
  { typedef typename yaul::tml::string<'l','l'> type; };
/// Specialization of the enum_hex_fmt_argt for <tt>size_t</tt>
template<>
  struct enum_hex_fmt_argt<size_t>
  { typedef typename yaul::tml::string<'z'> type; };
/** \endcond */

/** // doc: enum_hex_fmt {{{
 * \todo Write documentation
 */ // }}}
template<typename T, bool Negative>
  struct enum_hex_fmt;

/** \cond SHOW_TEMPLATE_SPECIALIZATIONS */
template<typename T>
  struct enum_hex_fmt<T,false>
    : yaul::tml::join<
        typename yaul::tml::join<
          yaul::tml::string<'0','x','%'>
        , typename enum_hex_fmt_prec<T>::type
        >::type
      , typename yaul::tml::join<
          typename enum_hex_fmt_argt<T>::type
        , yaul::tml::string<'x'>
        >::type
      >
  { };
/// Specialization of the enum_hex_fmt for <tt>lt;T, true&gt;</tt>
template<typename T>
  struct enum_hex_fmt<T,true>
    : yaul::tml::join<
        typename yaul::tml::join<
          yaul::tml::string<'-','0','x','%'>
        , typename enum_hex_fmt_prec<T>::type
        >::type
      , typename yaul::tml::join<
          typename enum_hex_fmt_argt<T>::type
        , yaul::tml::string<'x'>
        >::type
      >
  { };
/** \endcond */

} } // end namespace clxx::detail

namespace clxx {

/** // doc: enum2hex(x) {{{
 * \todo Write documentation
 */ // }}}
template<typename E>
std::string enum2hex(E x)
{
  typedef typename std::underlying_type<E>::type T;
  constexpr size_t size = 5 + 2 * sizeof(T);
  T t = static_cast<T>(x);
  char buf[size];
  char const *fmt;
  if (t < 0)
    {
      fmt = yaul::tml::c_str<typename detail::enum_hex_fmt<T,true>::type>::value;
      t = -t;
    }
  else
    {
      fmt = yaul::tml::c_str<typename detail::enum_hex_fmt<T,false>::type>::value;
    }
  std::snprintf(buf, size, fmt, t);
  return std::string(buf);
}

} // end namespace clxx
#endif /* CLXX_UTIL_ENUM2HEX_HPP_INCLUDED */
// vim: set expandtab tabstop=2 shiftwidth=2:
// vim: set foldmethod=marker foldcolumn=4:
